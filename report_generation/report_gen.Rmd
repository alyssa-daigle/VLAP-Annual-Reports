---
title: "2025 Volunteer Lake Assessment Program"
output:
  word_document:
    reference_docx: "template.docx"
params:
  lake: NULL
  station: NULL
  station_id: NULL
  town: NULL
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)

# Load dotenv if available
if (file.exists(".env")) {
  if (!requireNamespace("dotenv", quietly = TRUE)) {
    install.packages("dotenv")
  }
  library(dotenv)
  load_dot_env(".env")
}

# Access environment variables
project_path <- Sys.getenv("PROJECT_PATH")
plot_path <- Sys.getenv("OUTPUT_PATH")
reg_path <- Sys.getenv("REG_PATH")
table_path <- Sys.getenv("TABLE_PATH")

# Load libraries
library(knitr)
library(dplyr)
library(kableExtra)
library(flextable)
library(officer)
library(magrittr)
```

### **INDIVIDUAL REPORT: `r toupper(lake)` – `r town`**


**RECOMMENDED ACTIONS:** 

### **HISTORICAL WATER QUALITY TREND ANALYSIS**
``` {r trend table}

accent1_60 <- "#DCE6F1"  # same light blue fill

station_id <- params$station_id # change per lake

# Locate trend CSV
trend_file <- list.files(
  table_path,
  pattern = paste0("TrendSummary_", station_id, ".*\\.csv$"),
  full.names = TRUE,
  ignore.case = TRUE
)

if (length(trend_file) == 1) {
  trend_data <- read.csv(trend_file, stringsAsFactors = FALSE)
  
  # Clean column names and round numeric values
  trend_data <- trend_data |>
    rename_with(~ gsub("_", " ", .x)) |>
    mutate(across(where(is.numeric), round, 2))
  
  # Convert to flextable
  ft_trend <- flextable(trend_data) |>
    bold(part = "header") |>               # bold top row
    bold(j = 1, part = "body") |>          # bold first column
    bg(bg = accent1_60, part = "all") |>   # fill color
    border_outer(part = "all", border = fp_border(color="black", width=1)) |>
    border_inner_h(part = "all", border = fp_border(color="black", width=1)) |>
    border_inner_v(part = "all", border = fp_border(color="black", width=1)) |>
    align(align = "center", part = "header") |>  # center header row
    line_spacing(space = 1) |> 
    padding(padding.top = 0, padding.bottom = 0, part = "all") |> 
    fontsize(size = 10, part = "all") |>         # smaller text
    set_table_properties(width = 0.4, layout = "autofit") |>
    font(fontname = "Aptos", part = "all") |>
    autofit()
  
  ft_trend
  
} else {
  cat("**Trend summary not found for", station_id, "**")
}


```


### **HISTORICAL WATER QUALITY GRAPHICS - DEEP SPOT**
```{r plots, echo=FALSE, results='asis', out.width = '75%'}
station_id <- params$station_id

# Dynamic directories from environment variables
plot_dirs <- c(
  file.path(plot_path, "pH_conduc"),
  file.path(plot_path, "chl_tp_secchi"),
  file.path(plot_path, "temp_DO"),
  file.path(plot_path, "plankton")
)

# Find matching images
plot_files <- unlist(lapply(plot_dirs, function(d) {
  if (dir.exists(d)) {
    list.files(d, pattern = paste0(station_id, ".*\\.(png|jpg)$"),
            full.names = TRUE, ignore.case = TRUE)
  } else {
    character(0)
  }
}))

# Clean and limit to 4 images
plot_files <- plot_files[!is.na(plot_files) & plot_files != ""]
if (length(plot_files) > 4) plot_files <- plot_files[1:4]
```

```{r cond pH plot, out.width = '70%'}
if (length(plot_files) >= 1) knitr::include_graphics(plot_files[1])
```

```{r chl tp trans plot, out.width = '70%'}
if (length(plot_files) >= 2) knitr::include_graphics(plot_files[2])
```

```{r temp DO plot, out.width = '70%'}
if (length(plot_files) >= 3) knitr::include_graphics(plot_files[3])
```

```{r plankton, out.width = '70%'}
if (length(plot_files) >= 4) knitr::include_graphics(plot_files[4])
```

#### Table 1. 2025 Average Water Quality Data for `r toupper(lake)` – `r town`
```{r}
lake <- params$lake
accent1_60 <- "#DCE6F1"

# Replace spaces with underscores and escape any regex characters
lake_clean <- gsub(" ", "_", lake)
lake_clean <- gsub("([\\(\\)\\[\\]\\+\\?\\*\\.\\^\\$])", "\\\\\\1", lake_clean)

# Search for CYA CSV file
cya_file <- list.files(
  table_path,
  pattern = paste0("^", lake_clean, ".*_CYA\\.csv$"), # match start of filename
  full.names = TRUE,
  ignore.case = TRUE
)

if (length(cya_file) == 1) {
  cya_data <- read.csv(cya_file, check.names = FALSE, stringsAsFactors = FALSE)
  
  if ("STATNAME" %in% names(cya_data)) {
    names(cya_data)[names(cya_data) == "STATNAME"] <- "Station"
  }
  
  cya_data <- cya_data |>
    select(where(~ !all(is.na(.x) | .x == ""))) |>
    mutate(across(where(is.numeric), round, 2))
  
  ft_cya <- flextable(cya_data) |>
    bold(part = "header") |>
    bg(bg = accent1_60, part = "all") |>
    border_outer(part = "all", border = fp_border(color = "black", width = 1)) |>
    border_inner_h(part = "all", border = fp_border(color = "black", width = 1)) |>
    border_inner_v(part = "all", border = fp_border(color = "black", width = 1)) |>
    align(align = "center", part = "header") |>
    align(j = 1, i = 2:nrow(cya_data), align = "left", part = "body") |>
    align(j = 2:ncol(cya_data), align = "center", part = "body") |>
    line_spacing(space = 1) |> 
    padding(padding.top = 0, padding.bottom = 0, part = "all") |> 
    fontsize(size = 9.5, part = "all") |>          
    set_table_properties(layout = "autofit") |>
    font(fontname = "Aptos", part = "all")
  
  ft_cya
} else if (length(cya_file) == 0) {
  cat("**CYA summary not found for", lake, "**")
} else {
  cat("**Multiple CYA files found for", lake, "- please check directory**")
}


```


### **OBSERVATIONS** *(Refer to Table 1 and Historical Deep Spot Data Graphics)*:

- **CHLOROPHYLL-A:** 

- **CONDUCTIVITY / CHLORIDE:** 

- **COLOR:** 

- **TOTAL PHOSPHORUS:** 

- **TRANSPARENCY:** 

- **TURBIDITY:** 

- **PH:** 


#### **HOW DOES YOUR LAKE COMPARE TO NEW HAMPSHIRE LAKES & WATER QUALITY STANDARDS?**


##### **NH Median Lake Water Quality Values**

##### *Median values generated from historic lake monitoring data*

``` {r, echo = FALSE, warning = FALSE}

accent1_60 <- "#DCE6F1"

# --- NH Median Lake Water Quality Values ---
median_values <- data.frame(
  PARAMETER = c("Alkalinity", "Chlorophyll-a", "Chloride", "Conductivity", 
                "Total phosphorus", "Transparency", "pH"),
  `MEDIAN VALUE` = c("4.5 mg/L", "4.39 ug/L", "5 mg/L", "42.3 uS/cm",
                    "11 ug/L", "3.3 m", "6.6"),
  check.names = FALSE
)

ft_median <- flextable(median_values) |>
  bold(part = "header") |>
  bold(j = 1, part = "body") |>
  bg(bg = accent1_60, part = "all") |>
  border_outer(part = "all", border = fp_border(color="black", width=1)) |>
  border_inner_h(part = "all", border = fp_border(color="black", width=1)) |>
  border_inner_v(part = "all", border = fp_border(color="black", width=1)) |>
  align(align = "center", part = "header") |>   # center headers
  line_spacing(space = 1) |> 
    padding(padding.top = 0, padding.bottom = 0, part = "all") |> 
  fontsize(size = 10, part = "all") |>          # smaller text
  set_table_properties(width = 0.35, layout = "autofit") |>
  font(fontname = "Aptos", part = "all") |>
  autofit()

ft_median

```



##### **NH Water Quality Standards**

##### *Numeric criteria for specific parameters. Water quality violation occurs if thresholds are exceeded.*

``` {r}
# --- NH Water Quality Standards ---
water_quality_standards <- data.frame(
  PARAMETER = c("Chloride", "E. coli (beach)", "E. coli (surface water)", 
                "pH", "Turbidity"),
  THRESHOLD = c("> 230 mg/L (chronic)", "> 88 cts/100 mL", "> 406 cts/100 mL",
                "between 6.5-8.0 (unless naturally occurring)", 
                "> 10 NTU above natural"),
  check.names = FALSE
)

ft_standards <- flextable(water_quality_standards) |>
  bold(part = "header") |>
  bold(j = 1, part = "body") |>
  bg(bg = accent1_60, part = "all") |>
  border_outer(part = "all", border = fp_border(color="black", width=1)) |>
  border_inner_h(part = "all", border = fp_border(color="black", width=1)) |>
  border_inner_v(part = "all", border = fp_border(color="black", width=1)) |>
  align(align = "center", part = "header") |> 
  line_spacing(space = 1) |> 
    padding(padding.top = 0, padding.bottom = 0, part = "all") |> 
  fontsize(size = 10, part = "all") |> 
  set_table_properties(width = 0.5, layout = "autofit") |>
  font(fontname = "Aptos", part = "all") |>
  autofit()

ft_standards
```